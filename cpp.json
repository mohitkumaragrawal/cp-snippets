{
  "templates": {
    "prefix": "templates",
    "body": [
      "// ordered_set",
      "// debugs",
      "// cppt",
      "// sieve",
      "// modulo",
      "// sparse table",
      "// DSU",
      "// segtree",
      "// binary_lifting",
      "// euler_tour",
      "// hashing"
    ],
    "description": "list of available templates"
  },
  "ordered_set": {
    "prefix": "ordered_set",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "template <typename T, typename ComparatorFn = less<T>>",
      "using ordered_set = tree<T, null_type, ComparatorFn, rb_tree_tag,",
      "                         tree_order_statistics_node_update>;"
    ],
    "description": "policy based ordered_set"
  },
  "debugs": {
    "prefix": "debugs",
    "body": [
      "#ifdef _DEBUG",
      "void dbg_out() { cerr << endl; }",
      "template <typename Head, typename... Tail>",
      "void dbg_out(Head H, Tail... T) {",
      "\tcerr << ' ' << H;",
      "\tdbg_out(T...);",
      "}",
      "#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)",
      "#else",
      "#define dbg(...)",
      "#endif"
    ],
    "description": "debugging macros"
  },
  "cppt": {
    "prefix": "cppt",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define all(x) begin(x), end(x)",
      "#define OUT(T) cout << \"Case #\" << T << \": \"",
      "#ifndef _DEBUG",
      "#define endl '\\n'",
      "#endif",
      "#ifdef _DEBUG",
      "void dbg_out() { cerr << endl; }",
      "template <typename Head, typename... Tail>",
      "void dbg_out(Head H, Tail... T) {",
      "\tcerr << ' ' << H;",
      "\tdbg_out(T...);",
      "}",
      "#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)",
      "#else",
      "#define dbg(...)",
      "#endif",
      "#define ckmin(x, y) x = min((x), (y))",
      "#define ckmax(x, y) x = max((x), (y))",
      "",
      "// clang-format off",
      "template <typename T> ostream &operator<<(ostream &out, const vector<T> &v) { for (const auto &x : v) out << x << ' '; return out; }",
      "template <typename T> istream &operator>>(istream &in, vector<T> &v) { for (auto &x : v) in >> x; return in; }",
      "// clang-format on",
      "",
      "using ll = long long;",
      "using lld = long double;",
      "using pll = pair<ll, ll>;",
      "using pii = pair<int, int>;",
      "",
      "void solve(ll _t) {}",
      "",
      "int main() {",
      "  ios_base::sync_with_stdio(false), cin.tie(NULL);",
      "",
      "  ll T = 1;",
      "  cin >> T;",
      "  for (ll t = 1; t <= T; ++t)",
      "    solve(t);",
      "}"
    ],
    "description": "weird snippet"
  },
  "sieve": {
    "prefix": "sieve",
    "body": [
      "struct sieve_t {",
      "\tsieve_t(int n, bool gen_primes = false, bool gen_sieve = false) {",
      "\t\tis_prime.assign(n + 1, true);",
      "\t\tis_prime[0] = is_prime[1] = false;",
      "\t\tfor (int i = 2; i * i <= n; ++i) {",
      "\t\t\tfor (int j = i * i; j <= n; j += i) is_prime[j] = false;",
      "\t\t}",
      "\t\tif (gen_primes) {",
      "\t\t\tfor (int i = 2; i <= n; ++i) {",
      "\t\t\t\tif (is_prime[i]) primes.push_back(i);",
      "\t\t\t}",
      "\t\t}",
      "\t\tif (gen_sieve) {",
      "\t\t\tsieve.assign(n + 1, -1);",
      "\t\t\tfor (int i = 2; i <= n; ++i) {",
      "\t\t\t\tif (is_prime[i]) {",
      "\t\t\t\t\tsieve[i] = i;",
      "\t\t\t\t\tif ((ll)i * i <= n) {",
      "\t\t\t\t\t\tfor (int j = i * i; j <= n; j += i) {",
      "\t\t\t\t\t\t\tif (sieve[j] == -1) sieve[j] = i;",
      "\t\t\t\t\t\t}",
      "\t\t\t\t\t}",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t// requires gen_fact; works only upto sz;",
      "\tvector<int> fast_factorize(int k) {",
      "\t\tvector<int> res;",
      "\t\twhile (k > 1) {",
      "\t\t\tll p = sieve[k];",
      "\t\t\tres.push_back(p);",
      "\t\t\tk /= p;",
      "\t\t}",
      "\t\treturn res;",
      "\t}",
      "\t// requies gen_primes; works upto sz*sz;",
      "\tvector<int> factorize(int k) {",
      "\t\tvector<int> res;",
      "\t\tfor (int p : primes) {",
      "\t\t\tif (p * p > k) break;",
      "\t\t\twhile (k % p == 0) {",
      "\t\t\t\tk /= p;",
      "\t\t\t\tres.push_back(p);",
      "\t\t\t}",
      "\t\t}",
      "\t\tif (k > 1) res.push_back(k);",
      "\t\treturn res;",
      "\t}",
      "\tvector<bool> is_prime;",
      "\tvector<int> primes;",
      "\tvector<int> sieve;",
      "};"
    ],
    "description": "my sieve template"
  },
  "modulo": {
    "prefix": "modulo",
    "body": [
      "const ll MOD = 1e9 + 7;",
      "ll binexp(ll a, ll b, ll p = MOD) {",
      "\tif (b < 0) return 0;",
      "\tll res = 1;",
      "\twhile (b > 0) {",
      "\t\tif (b & 1) b--, res = (res * a) % p;",
      "\t\ta = (a * a) % p;",
      "\t\tb >>= 1;",
      "\t}",
      "\treturn res;",
      "}",
      "",
      "inline ll modinv(ll x, ll p = MOD) { return binexp(x, p - 2, p); }",
      "template <ll mod>",
      "struct MODINT_ {",
      "\tll value;",
      "\tMODINT_() = default;",
      "\tMODINT_(ll x) : value(x % mod) {}",
      "\tMODINT_(const MODINT_& m) : value(m.value % mod) {}",
      "\tMODINT_& operator=(const MODINT_& m) {",
      "\t\tvalue = m.value;",
      "\t\treturn *this;",
      "\t}",
      "\tll inverse_value() const { return modinv(value, mod); }",
      "\tMODINT_& operator+=(const MODINT_& m) {",
      "\t\tvalue = (value + m.value) % mod;",
      "\t\treturn *this;",
      "\t}",
      "\tMODINT_& operator-=(const MODINT_& m) {",
      "\t\tvalue = (mod + value - m.value) % mod;",
      "\t\treturn *this;",
      "\t}",
      "\tMODINT_& operator*=(const MODINT_& m) {",
      "\t\tvalue = (value * m.value) % mod;",
      "\t\treturn *this;",
      "\t}",
      "\tMODINT_& operator/=(const MODINT_& m) {",
      "\t\tvalue = (value * m.inverse_value()) % mod;",
      "\t\treturn *this;",
      "\t}",
      "\tMODINT_& operator++() {",
      "\t\tvalue++;",
      "\t\tvalue %= mod;",
      "\t\treturn *this;",
      "\t}",
      "\tMODINT_& operator--() {",
      "\t\tvalue--;",
      "\t\tvalue %= mod;",
      "\t\treturn *this;",
      "\t}",
      "\tMODINT_ operator*(const MODINT_& b) { return MODINT_(value * b.value); }",
      "\tMODINT_ operator*(ll b) { return MODINT_(value * b); }",
      "\tMODINT_ operator-(const MODINT_& b) { return MODINT_(mod + value - b.value); }",
      "\tMODINT_ operator-(ll b) { return MODINT_(mod + value - b); }",
      "\tMODINT_ operator+(const MODINT_& b) { return MODINT_(value + b.value); }",
      "\tMODINT_ operator+(ll b) { return MODINT_(value + b); }",
      "\tMODINT_ operator/(const MODINT_& b) {",
      "\t\treturn MODINT_(value * modinv(b.value, mod));",
      "\t}",
      "\tMODINT_ operator/(ll b) { return MODINT_(value * modinv(b, mod)); }",
      "};",
      "template <ll mod>",
      "ostream& operator<<(ostream& out, const MODINT_<mod>& m) {",
      "\tout << m.value % mod;",
      "\treturn out;",
      "}",
      "template <ll mod>",
      "istream& operator>>(istream& in, MODINT_<mod>& m) {",
      "\tll x;",
      "\tin >> x;",
      "\tm.value = (x % mod);",
      "\treturn in;",
      "}",
      "using MODINT = MODINT_<MOD>;",
      "vector<MODINT> factorial;",
      "void init_factorial() {",
      "\tfactorial.resize(1000005);",
      "\tfactorial[0] = factorial[1] = 1;",
      "\tfor (ll i = 2; i < 1000005; ++i) {",
      "\t\tfactorial[i] = (factorial[i - 1] * i);",
      "\t}",
      "}",
      "inline MODINT choose(const MODINT& a, const MODINT& b) {",
      "\tif (a.value < b.value) return 0;",
      "\treturn factorial[a.value] /",
      "\t\t\t\t (factorial[b.value] * factorial[(a.value - b.value)]);",
      "}"
    ],
    "description": "modulo operations"
  },
  "sparse": {
    "prefix": "sparse table",
    "body": [
      "struct min_op {",
      "  ll operator()(ll a, ll b) { return min(a, b); }",
      "};",
      "struct max_op {",
      "  ll operator()(ll a, ll b) { return max(a, b); }",
      "};",
      "struct gcd_op {",
      "  ll operator()(ll a, ll b) { return __gcd(a, b); }",
      "};",
      "template <typename OperationT>",
      "struct sparse_table {",
      "  vector<vector<ll>> m;",
      "  OperationT op;",
      "  template <typename Itr>",
      "  void init(Itr begin, Itr end) {",
      "    ll sz = end - begin;",
      "    ll lg = 63 - __builtin_clzll(sz);",
      "    m.assign(sz, vector<ll>(lg + 1));",
      "    for (ll j = 0; j <= lg; ++j) {",
      "      ll len = (1 << j);",
      "      for (ll i = 0; i + len - 1 < sz; ++i) {",
      "        if (len == 1) {",
      "          m[i][j] = *(begin + i);",
      "        } else {",
      "          m[i][j] = op(m[i][j - 1], m[i + (1 << (j - 1))][j - 1]);",
      "        }",
      "      }",
      "    }",
      "  }",
      "  ll query(ll L, ll R) {",
      "    ll j = 63 - __builtin_clzll((R - L + 1));",
      "    return op(m[L][j], m[R + 1 - (1 << j)][j]);",
      "  }",
      "};"
    ],
    "description": "sparse table"
  },
  "DSU": {
    "prefix": "DSU",
    "body": [
      "struct DSU {",
      "  vector<int> parent, siz;",
      "  void init(int n) {",
      "    parent.resize(n);",
      "    siz.resize(n);",
      "    for (int i = 0; i < n; i++) {",
      "      parent[i] = i;",
      "      siz[i] = 1;",
      "    }",
      "  }",
      "  int find(int x) {",
      "    if (x == parent[x]) return x;",
      "    return parent[x] = find(parent[x]);",
      "  }",
      "  void merge(int x, int y) {",
      "    x = find(x);",
      "    y = find(y);",
      "    if (x == y) return;",
      "    if (siz[x] < siz[y]) swap(x, y);",
      "    parent[y] = x;",
      "    siz[x] += siz[y];",
      "  }",
      "  int size(int x) { return siz[find(x)]; }",
      "  bool same(int x, int y) { return find(x) == find(y); }",
      "};"
    ],
    "description": "disjoint set union"
  },
  "SegTree": {
    "prefix": "segtree",
    "body": [
      "template <typename T, typename CombineT>",
      "struct SegmentTree {",
      "  vector<T> tree;",
      "  CombineT combine;",
      "  T defaultValue;",
      "  ll n;",
      "",
      "  void init(ll n, T val) {",
      "    tree.resize(4 * n);",
      "    this->n = n;",
      "    defaultValue = val;",
      "    build_tree(1, 0, n - 1);",
      "  }",
      "",
      "  template<typename Itr>",
      "  void init(Itr begin, Itr end) {",
      "    n = distance(begin, end);",
      "    tree.resize(4 * n);",
      "",
      "    build_tree(1, 0, n-1, begin);",
      "  }",
      "  ",
      "  void build_tree(ll id, ll tl, ll tr) {",
      "    if (tl == tr) {",
      "      tree[id] = defaultValue;",
      "      return;",
      "    }",
      "    ll tm = (tl + tr) / 2;",
      "    build_tree(id * 2, tl, tm);",
      "    build_tree(id * 2 + 1, tm + 1, tr);",
      "    tree[id] = combine(tree[id * 2], tree[id * 2 + 1]);",
      "  }",
      "",
      "  template<typename Itr>",
      "  void build_tree(ll id, ll tl, ll tr, Itr begin) {",
      "    if (tl == tr) {",
      "      tree[id] = *(begin + tl);",
      "      return;",
      "    }",
      "    ll tm = (tl + tr) / 2;",
      "    build_tree(id * 2, tl, tm, begin);",
      "    build_tree(id * 2 + 1, tm + 1, tr, begin);",
      "    tree[id] = combine(tree[id * 2], tree[id * 2 + 1]);",
      "  }",
      "",
      "  T query(ll id, ll tl, ll tr, ll ql, ll qr) {",
      "    if (ql > tr || tl > qr) return defaultValue;",
      "    if (ql <= tl && tr <= qr) return tree[id];",
      "    ll tm = (tl + tr) / 2;",
      "    return combine(query(id * 2, tl, tm, ql, qr),",
      "                   query(id * 2 + 1, tm + 1, tr, ql, qr));",
      "  }",
      "",
      "  T query(ll l, ll r) { return query(1, 0, n - 1, l, r); }",
      "",
      "  void update(ll id, ll tl, ll tr, ll p, T x) {",
      "    if (tl == tr) {",
      "      tree[id] = x;",
      "      return;",
      "    }",
      "    ll tm = (tl + tr) / 2;",
      "    if (p <= tm)",
      "      update(id * 2, tl, tm, p, x);",
      "    else",
      "      update(id * 2 + 1, tm + 1, tr, p, x);",
      "    tree[id] = combine(tree[id * 2], tree[id * 2 + 1]);",
      "  }",
      "",
      "  void update(ll p, T x) { update(1, 0, n - 1, p, x); }",
      "};"
    ],
    "description": "Point update segment tree"
  },
  "binary_lift": {
    "prefix": "binary_lifting",
    "body": [
      "struct binary_lift {",
      "  vector<vector<ll>> children;",
      "  vector<ll> depth;",
      "  const ll LOG = 18;",
      "  void init(vector<vector<ll>> &adj) {",
      "    ll n = adj.size();",
      "    depth.resize(n);",
      "    children.assign(n, vector<ll>(LOG + 1));",
      "    function<void(ll, ll, ll)> dfs = [&](ll u, ll p, ll d) {",
      "      depth[u] = d;",
      "      children[u][0] = p;",
      "      for (ll i = 1; i <= LOG; ++i) {",
      "        children[u][i] = children[children[u][i - 1]][i - 1];",
      "      }",
      "      for (ll v : adj[u]) {",
      "        if (v != p) dfs(v, u, d + 1);",
      "      }",
      "    };",
      "    dfs(0, 0, 0);",
      "  }",
      "  ll lift_node(ll n, ll d) {",
      "    for (ll i = LOG; i >= 0; --i) {",
      "      if (d & (1 << i)) n = children[n][i];",
      "    }",
      "    return n;",
      "  }",
      "  ll lca(ll u, ll v) {",
      "    if (depth[u] < depth[v]) swap(u, v);",
      "    u = lift_node(u, depth[u] - depth[v]);",
      "    if (u == v) return u;",
      "    for (ll i = LOG; i >= 0; --i) {",
      "      if (children[u][i] != children[v][i]) {",
      "        u = children[u][i];",
      "        v = children[v][i];",
      "      }",
      "    }",
      "    return children[u][0];",
      "  }",
      "  ll dist(ll u, ll v) { return depth[u] + depth[v] - 2 * depth[lca(u, v)]; }",
      "};"
    ],
    "description": "binary lifting"
  },
  "euler_tour": {
    "prefix": "euler_tour",
    "body": [
      "struct euler_tour {",
      "  vector<ll> in, out;",
      "  ll timer = 0;",
      "  void init(vector<vector<ll>> &adj) {",
      "    ll n = adj.size();",
      "    in.resize(n);",
      "    out.resize(n);",
      "    function<void(ll, ll)> dfs = [&](ll u, ll p) {",
      "      in[u] = timer++;",
      "      for (ll v : adj[u]) {",
      "        if (v != p) dfs(v, u);",
      "      }",
      "      out[u] = timer++;",
      "    };",
      "    dfs(0, 0);",
      "  }",
      "  bool is_ancestor(ll u, ll v) { return in[u] <= in[v] && out[u] >= out[v]; }",
      "};"
    ]
  },
  "hashing": {
    "prefix": "hashing",
    "body": [
      "const vector<ll> hash_mods = {1000000007, 1000000009};",
      "const ll hash_base = 31;",
      "vector<vector<ll>> hash_powers, hash_powers_invs;",
      "void init_hashing(ll size) {",
      "  hash_powers.resize(hash_mods.size());",
      "  for (int i = 0; i < hash_mods.size(); ++i) {",
      "    hash_powers[i].resize(size);",
      "    hash_powers[i][0] = 1;",
      "    for (int j = 1; j < size; ++j) {",
      "      hash_powers[i][j] = (hash_powers[i][j - 1] * hash_base) % hash_mods[i];",
      "    }",
      "  }",
      "  hash_powers_invs.resize(hash_mods.size());",
      "  for (int i = 0; i < hash_mods.size(); ++i) {",
      "    ll has_base_inv = modinv(hash_base, hash_mods[i]);",
      "    hash_powers_invs[i].resize(size);",
      "    hash_powers_invs[i][0] = 1;",
      "    for (int j = 1; j < size; ++j) {",
      "      hash_powers_invs[i][j] =",
      "          (hash_powers_invs[i][j - 1] * has_base_inv) % hash_mods[i];",
      "    }",
      "  }",
      "}",
      "vector<ll> hash_string(const string &str) {",
      "  vector<ll> hash(hash_mods.size());",
      "  for (ll i = 0; i < hash_mods.size(); ++i) {",
      "    for (ll j = 0; j < str.size(); ++j) {",
      "      hash[i] =",
      "          (hash[i] + (str[j] - 'a' + 1) * hash_powers[i][j]) % hash_mods[i];",
      "    }",
      "  }",
      "  return hash;",
      "}",
      "vector<ll> hash_character(char ch, ll pos) {",
      "  vector<ll> hash(hash_mods.size());",
      "  for (ll i = 0; i < hash_mods.size(); ++i) {",
      "    hash[i] = (hash[i] + (ch - 'a' + 1) * hash_powers[i][pos]) % hash_mods[i];",
      "  }",
      "  return hash;",
      "}",
      "// result = factor_a * hash_a + factor_b * hash_b wit the respective modulo",
      "vector<ll> hash_linear_combination(const vector<ll> &a, ll factor_a,",
      "                                   const vector<ll> &b, ll factor_b) {",
      "  vector<ll> result(a.size());",
      "  for (ll i = 0; i < a.size(); ++i) {",
      "    result[i] = (factor_a * a[i] + factor_b * b[i]);",
      "    while (result[i] < 0) result[i] += hash_mods[i];",
      "    result[i] %= hash_mods[i];",
      "  }",
      "  return result;",
      "}",
      "vector<ll> operator+(const vector<ll> &a, const vector<ll> &b) {",
      "  return hash_linear_combination(a, 1, b, 1);",
      "}",
      "vector<ll> operator-(const vector<ll> &a, const vector<ll> &b) {",
      "  return hash_linear_combination(a, 1, b, -1);",
      "}",
      "vector<ll> operator<<(const vector<ll> &a, ll shift) {",
      "  vector<ll> result(a.size());",
      "  for (ll i = 0; i < a.size(); ++i) {",
      "    result[i] = (a[i] * hash_powers[i][shift]) % hash_mods[i];",
      "  }",
      "  return result;",
      "}",
      "vector<ll> operator>>(const vector<ll> &a, ll shift) {",
      "  vector<ll> result(a.size());",
      "  for (ll i = 0; i < a.size(); ++i) {",
      "    result[i] = (a[i] * hash_powers_invs[i][shift]) % hash_mods[i];",
      "  }",
      "  return result;",
      "}"
    ]
  },
  "lazy segment tree": {
    "prefix": "lazy segtree",
    "body": [
      "template <typename node_type, typename tag_type>",
      "struct lazy_segtree {",
      "  vector<node_type> tree;",
      "  vector<tag_type> lazy;",
      "  int n;",
      "  template <typename Iter>",
      "  void init(Iter first, Iter last, int nn = -1) {",
      "    n = nn;",
      "    if (n == -1) n = distance(first, last);",
      "    tree.resize(4 * n);",
      "    lazy.resize(4 * n);",
      "    build_tree(0, 0, n - 1, first);",
      "  }",
      "  node_type query(int ql, int qr) { return query(0, 0, n - 1, ql, qr); }",
      "  void update(int ql, int qr, tag_type const &val) {",
      "    update(0, 0, n - 1, ql, qr, val);",
      "  }",
      " private:",
      "  template <typename Iter>",
      "  void build_tree(int id, int tl, int tr, Iter first) {",
      "    if (tl == tr) {",
      "      tree[id].init(tl, tr, *(first + tl));",
      "      lazy[id].init(tl, tr);",
      "      return;",
      "    }",
      "    int tm = (tl + tr) / 2;",
      "    build_tree(2 * id + 1, tl, tm, first);",
      "    build_tree(2 * id + 2, tm + 1, tr, first);",
      "    tree[id] = node_type::merge(tree[2 * id + 1], tree[2 * id + 2]);",
      "    lazy[id].init(tl, tr);",
      "  }",
      "  void push(int id, int tl, int tr) {",
      "    if (tl != tr) {",
      "      int tm = (tl + tr) / 2;",
      "      tree[2 * id + 1].apply(tl, tm, lazy[id]);",
      "      lazy[2 * id + 1].merge(lazy[id]);",
      "      tree[2 * id + 2].apply(tm + 1, tr, lazy[id]);",
      "      lazy[2 * id + 2].merge(lazy[id]);",
      "    }",
      "    lazy[id].reset();",
      "  }",
      "  node_type query(int id, int tl, int tr, int ql, int qr) {",
      "    if (tl > qr || ql > tr) return node_type::phi();",
      "    if (ql <= tl && tr <= qr) return tree[id];",
      "    push(id, tl, tr);",
      "    int tm = (tl + tr) / 2;",
      "    return node_type::merge(query(2 * id + 1, tl, tm, ql, qr),",
      "                            query(2 * id + 2, tm + 1, tr, ql, qr));",
      "  }",
      "  void update(int id, int tl, int tr, int ql, int qr, tag_type const &val) {",
      "    if (tl > qr || ql > tr) return;",
      "    if (ql <= tl && tr <= qr) {",
      "      tree[id].apply(tl, tr, val);",
      "      lazy[id].merge(val);",
      "      return;",
      "    }",
      "    push(id, tl, tr);",
      "    int tm = (tl + tr) / 2;",
      "    update(2 * id + 1, tl, tm, ql, qr, val);",
      "    update(2 * id + 2, tm + 1, tr, ql, qr, val);",
      "    tree[id] = node_type::merge(tree[2 * id + 1], tree[2 * id + 2]);",
      "  }",
      "};",
      "struct tag {",
      "  ll inc;",
      "  void reset() { inc = 0; }",
      "  void merge(tag const &other) { inc += other.inc; }",
      "  void init(int tl, int tr) {}",
      "};",
      "struct node {",
      "  static node phi() { return {0LL}; }",
      "  static node merge(node const &a, node const &b) { return {a.data + b.data}; }",
      "  ll data;",
      "  void apply(ll tl, ll tr, tag const &t) { data += (tr - tl + 1) * t.inc; }",
      "  template <typename T>",
      "  void init(ll tl, ll tr, T &ddata) {",
      "    this->data = ddata;",
      "  }",
      "};"
    ]
  }
}
